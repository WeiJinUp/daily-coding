# 工程方法论

> 从实践中总结，应用到实践中去

## 概述

本模块记录在工作和学习过程中沉淀下来的**方法论和思维模型**，包括：

- **业务分析方法**：如何快速理解和分析业务需求
- **系统设计思维**：如何设计可扩展、可维护的系统
- **问题解决框架**：遇到问题时的系统化思考方式
- **技术决策模型**：如何做出合理的技术选型

这些内容不是空谈理论，而是从实际项目中提炼出的**通用规律和解决方案**，可以应用到类似的业务场景中。

---

## 业务分析

### 需求理解框架

#### 1. 理解业务背景（Why）

**关键问题**：
- 这个需求要解决什么问题？
- 目标用户是谁？痛点是什么？
- 为什么现在要做这个功能？
- 预期带来什么价值？

**分析方法**：
- 5W1H 分析法（What, Why, Who, When, Where, How）
- 用户故事地图
- 价值主张画布

---

#### 2. 拆解核心功能（What）

**关键问题**：
- 核心功能是什么？次要功能是什么？
- MVP（最小可行产品）包含哪些？
- 功能之间的依赖关系是什么？
- 优先级如何排序？

**分析工具**：
- 功能分解树
- 用户旅程地图
- MoSCoW 优先级（Must, Should, Could, Won't）

---

#### 3. 识别关键实体（Domain）

**关键问题**：
- 业务领域中有哪些核心实体？
- 实体之间的关系是什么？
- 每个实体的生命周期是怎样的？
- 关键业务规则和约束是什么？

**建模方法**：
- 领域驱动设计（DDD）
- 实体关系图（ER Diagram）
- 状态机图

---

#### 4. 梳理业务流程（How）

**关键问题**：
- 正常流程是怎样的？
- 异常情况如何处理？
- 哪些环节可以异步处理？
- 哪些环节需要事务保证？

**工具方法**：
- 流程图
- 时序图
- 泳道图

---

### 案例：电商订单系统分析

#### 业务背景
- **问题**：用户购物后需要下单结算
- **用户**：平台买家
- **痛点**：结算流程复杂，容易出错
- **价值**：提升转化率，减少客服咨询

#### 核心功能
- **必须有**（Must）：创建订单、支付、订单查询
- **应该有**（Should）：优惠券、发票
- **可以有**（Could）：拼团、预约
- **暂不做**（Won't）：分期付款

#### 关键实体
- **订单**（Order）：订单号、金额、状态
- **订单项**（OrderItem）：商品、数量、价格
- **支付单**（Payment）：支付方式、支付状态
- **物流单**（Shipment）：快递公司、运单号

#### 业务流程
```
选购商品 → 提交订单 → 库存锁定 → 支付 → 扣减库存 → 发货 → 确认收货
```

---

## 系统设计

### 设计思维模型

#### 1. 分层架构思维

**典型分层**：
```
展现层（Controller）  - 接收请求，返回响应
应用层（Service）      - 业务逻辑编排
领域层（Domain）       - 核心业务规则
基础设施层（Infra）    - 数据持久化、外部调用
```

**设计原则**：
- 上层依赖下层，下层不知道上层
- 每层职责单一，边界清晰
- 跨层调用需要通过接口

---

#### 2. 高内聚低耦合

**什么是高内聚？**
- 相关的功能放在一起
- 模块内部联系紧密
- 职责清晰明确

**什么是低耦合？**
- 模块之间独立
- 通过接口交互
- 减少依赖关系

**实践方法**：
- 单一职责原则
- 依赖倒置原则
- 使用设计模式解耦

---

#### 3. 可扩展性设计

**扩展方式**：
- **垂直扩展**：提升单机性能（Scale Up）
- **水平扩展**：增加机器数量（Scale Out）
- **功能扩展**：新增功能不影响原有代码

**设计策略**：
- 无状态设计
- 异步化处理
- 缓存分层
- 读写分离
- 微服务架构

---

#### 4. 容错与降级

**容错设计**：
- 超时控制
- 重试机制
- 熔断降级
- 限流保护

**降级策略**：
- 功能降级：关闭非核心功能
- 服务降级：返回默认值
- 读降级：只读不写
- 写降级：异步写入

---

### 案例：秒杀系统设计

#### 业务特点
- **高并发**：瞬时请求量巨大
- **读多写少**：查询远多于下单
- **库存有限**：商品数量有限
- **防超卖**：不能卖出超过库存的商品

#### 设计方案

**1. 前端优化**
- 按钮置灰，防止重复点击
- 本地倒计时，减少请求
- 图片懒加载，加快页面响应

**2. 网关层**
- 限流：每秒最多处理 X 个请求
- 黑名单：拦截恶意 IP
- 验证码：人机验证

**3. 应用层**
- 库存预热：提前加载到缓存
- 异步下单：MQ 削峰填谷
- 限流降级：超过阈值返回友好提示

**4. 数据层**
- Redis 扣减库存：高性能
- 数据库兜底：最终一致性
- 分库分表：分散压力

---

## 问题解决

### 系统化思考框架

#### 1. 定义问题（Define）

**明确症状**：
- 现象是什么？
- 影响范围多大？
- 什么时候开始的？
- 频率如何？

**示例**：
- ❌ "系统很慢"
- ✅ "用户下单接口响应时间从 100ms 增加到 3000ms，影响 30% 用户，从昨天下午 2 点开始"

---

#### 2. 分析原因（Analyze）

**可能的原因**：
- 代码问题：逻辑错误、性能问题
- 配置问题：参数设置不当
- 环境问题：资源不足、网络问题
- 依赖问题：第三方服务异常

**分析方法**：
- 日志分析
- 监控数据
- 代码走查
- 压测验证

---

#### 3. 制定方案（Solution）

**方案评估**：
- 可行性：技术上能实现吗？
- 成本：需要多少时间和资源？
- 风险：会不会引入新问题？
- 效果：能解决多少问题？

**方案类型**：
- **临时方案**：快速止血
- **长期方案**：根本解决
- **备选方案**：Plan B

---

#### 4. 执行验证（Execute）

**执行步骤**：
- 灰度发布：小范围验证
- 监控观察：关注关键指标
- 及时回滚：发现问题快速回退
- 总结复盘：记录经验教训

---

### 案例：接口超时问题排查

#### 问题现象
- 订单提交接口响应时间 > 5s
- 影响 50% 的用户
- 从今天上午 10 点开始

#### 排查过程

**1. 查看监控**
- 发现数据库 CPU 100%
- 慢查询数量激增

**2. 分析慢查询**
- 某个查询没有走索引
- 新上线的代码引入

**3. 临时方案**
- 添加缺失的索引
- 优化查询条件

**4. 长期方案**
- 完善代码评审流程
- 增加数据库性能测试
- 优化监控告警规则

---

## 技术决策

### 技术选型框架

#### 评估维度

**1. 功能适配度**
- 能否满足当前需求？
- 是否支持未来扩展？

**2. 性能指标**
- 吞吐量
- 延迟
- 资源消耗

**3. 成本考量**
- 学习成本
- 开发成本
- 维护成本
- 云服务成本

**4. 团队匹配度**
- 团队是否熟悉？
- 学习曲线如何？
- 是否有人能 Hold 住？

**5. 社区生态**
- 是否开源？
- 社区活跃度
- 文档是否完善
- 遇到问题能否快速解决

---

### 案例：缓存选型

#### 需求
- 需要缓存用户会话信息
- 需要支持过期时间
- 需要支持分布式

#### 候选方案

**Redis**
- ✅ 性能优秀（10 万 QPS+）
- ✅ 支持丰富数据结构
- ✅ 成熟稳定，社区活跃
- ❌ 内存成本较高

**Memcached**
- ✅ 性能极致
- ✅ 内存效率高
- ❌ 数据结构单一
- ❌ 持久化支持较弱

**本地缓存（Caffeine）**
- ✅ 性能最快
- ✅ 无网络开销
- ❌ 不支持分布式
- ❌ 数据不共享

#### 决策
选择 **Redis**，理由：
- 团队熟悉，运维成熟
- 功能完善，满足需求
- 虽然成本高，但可接受

---

## 持续沉淀

工程方法论不是一蹴而就的，而是在实践中不断积累和完善的过程。

### 如何建立自己的方法论？

1. **记录问题**：遇到问题时记录下来
2. **总结规律**：相似问题的共同点
3. **提炼方法**：抽象出通用解决方案
4. **实践验证**：在新问题中验证和优化
5. **分享交流**：与他人讨论，吸收不同视角

### 推荐阅读

- 《领域驱动设计》- Eric Evans
- 《凤凰项目》- Gene Kim
- 《架构整洁之道》- Robert C. Martin
- 《Google SRE》- Google

---

本模块将持续更新在实践中总结的新方法和新思考。

如果你有好的方法论或案例，欢迎通过 [Issues](https://github.com/WeiJinUp/daily-coding/issues) 分享讨论！

